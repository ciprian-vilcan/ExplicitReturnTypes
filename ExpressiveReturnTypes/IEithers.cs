// <auto-generated />
namespace ExpressiveReturnTypes
{
    using System;
    
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    public interface IEither<out T1>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    public interface IEither<out T1, out T2>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    public interface IEither<out T1, out T2, out T3>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    /// <typeparam name="T11"> Option 11. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <param name="func11"> The func to be executed in case the type is option 11. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10, Func<T11, TResult> func11);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    /// <typeparam name="T11"> Option 11. </typeparam>
    /// <typeparam name="T12"> Option 12. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <param name="func11"> The func to be executed in case the type is option 11. </param>
            /// <param name="func12"> The func to be executed in case the type is option 12. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10, Func<T11, TResult> func11, Func<T12, TResult> func12);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    /// <typeparam name="T11"> Option 11. </typeparam>
    /// <typeparam name="T12"> Option 12. </typeparam>
    /// <typeparam name="T13"> Option 13. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <param name="func11"> The func to be executed in case the type is option 11. </param>
            /// <param name="func12"> The func to be executed in case the type is option 12. </param>
            /// <param name="func13"> The func to be executed in case the type is option 13. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10, Func<T11, TResult> func11, Func<T12, TResult> func12, Func<T13, TResult> func13);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    /// <typeparam name="T11"> Option 11. </typeparam>
    /// <typeparam name="T12"> Option 12. </typeparam>
    /// <typeparam name="T13"> Option 13. </typeparam>
    /// <typeparam name="T14"> Option 14. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <param name="func11"> The func to be executed in case the type is option 11. </param>
            /// <param name="func12"> The func to be executed in case the type is option 12. </param>
            /// <param name="func13"> The func to be executed in case the type is option 13. </param>
            /// <param name="func14"> The func to be executed in case the type is option 14. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10, Func<T11, TResult> func11, Func<T12, TResult> func12, Func<T13, TResult> func13, Func<T14, TResult> func14);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    /// <typeparam name="T11"> Option 11. </typeparam>
    /// <typeparam name="T12"> Option 12. </typeparam>
    /// <typeparam name="T13"> Option 13. </typeparam>
    /// <typeparam name="T14"> Option 14. </typeparam>
    /// <typeparam name="T15"> Option 15. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <param name="func11"> The func to be executed in case the type is option 11. </param>
            /// <param name="func12"> The func to be executed in case the type is option 12. </param>
            /// <param name="func13"> The func to be executed in case the type is option 13. </param>
            /// <param name="func14"> The func to be executed in case the type is option 14. </param>
            /// <param name="func15"> The func to be executed in case the type is option 15. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10, Func<T11, TResult> func11, Func<T12, TResult> func12, Func<T13, TResult> func13, Func<T14, TResult> func14, Func<T15, TResult> func15);
    }
    
    /// <summary>
    /// Defines the contract for data types that will act as an exclusive or (XOR) discriminated unions.
    /// </summary>
    /// <typeparam name="T1"> Option 1. </typeparam>
    /// <typeparam name="T2"> Option 2. </typeparam>
    /// <typeparam name="T3"> Option 3. </typeparam>
    /// <typeparam name="T4"> Option 4. </typeparam>
    /// <typeparam name="T5"> Option 5. </typeparam>
    /// <typeparam name="T6"> Option 6. </typeparam>
    /// <typeparam name="T7"> Option 7. </typeparam>
    /// <typeparam name="T8"> Option 8. </typeparam>
    /// <typeparam name="T9"> Option 9. </typeparam>
    /// <typeparam name="T10"> Option 10. </typeparam>
    /// <typeparam name="T11"> Option 11. </typeparam>
    /// <typeparam name="T12"> Option 12. </typeparam>
    /// <typeparam name="T13"> Option 13. </typeparam>
    /// <typeparam name="T14"> Option 14. </typeparam>
    /// <typeparam name="T15"> Option 15. </typeparam>
    /// <typeparam name="T16"> Option 16. </typeparam>
    public interface IEither<out T1, out T2, out T3, out T4, out T5, out T6, out T7, out T8, out T9, out T10, out T11, out T12, out T13, out T14, out T15, out T16>
    {
            /// <summary>/// Does pattern matching based on the real underlying type.
            /// </summary>
            /// <param name="func1"> The func to be executed in case the type is option 1. </param>
            /// <param name="func2"> The func to be executed in case the type is option 2. </param>
            /// <param name="func3"> The func to be executed in case the type is option 3. </param>
            /// <param name="func4"> The func to be executed in case the type is option 4. </param>
            /// <param name="func5"> The func to be executed in case the type is option 5. </param>
            /// <param name="func6"> The func to be executed in case the type is option 6. </param>
            /// <param name="func7"> The func to be executed in case the type is option 7. </param>
            /// <param name="func8"> The func to be executed in case the type is option 8. </param>
            /// <param name="func9"> The func to be executed in case the type is option 9. </param>
            /// <param name="func10"> The func to be executed in case the type is option 10. </param>
            /// <param name="func11"> The func to be executed in case the type is option 11. </param>
            /// <param name="func12"> The func to be executed in case the type is option 12. </param>
            /// <param name="func13"> The func to be executed in case the type is option 13. </param>
            /// <param name="func14"> The func to be executed in case the type is option 14. </param>
            /// <param name="func15"> The func to be executed in case the type is option 15. </param>
            /// <param name="func16"> The func to be executed in case the type is option 16. </param>
            /// <typeparam name="TResult"> The type of result. </typeparam>
            /// <returns> The <see cref="TResult"/>. </returns>
            TResult Match<TResult>(Func<T1, TResult> func1, Func<T2, TResult> func2, Func<T3, TResult> func3, Func<T4, TResult> func4, Func<T5, TResult> func5, Func<T6, TResult> func6, Func<T7, TResult> func7, Func<T8, TResult> func8, Func<T9, TResult> func9, Func<T10, TResult> func10, Func<T11, TResult> func11, Func<T12, TResult> func12, Func<T13, TResult> func13, Func<T14, TResult> func14, Func<T15, TResult> func15, Func<T16, TResult> func16);
    }
}

